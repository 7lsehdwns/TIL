# 영속성 관리

## 영속성 컨텍스트
> JPA를 이해하는 가장 중요한 용어  
> "엔티티를 영구 저장하는 환경"  


- 영속성 컨텍스트는 눈에 보이지 않는 논리적인 개념이다.
- 엔티티 매니저를 통해 영속성 컨텍스트에 접근한다.

## 엔티티의 생명주기
> 비영속
- 영속성 컨텍스트와 전혀 관계없는 새로운 상태
  ```java
  // 객체를 생성한 상태는 비영속이다
  Member member = new Member(); 
  member.setId("member1"); 
  member.setUsername("회원1");
  ```
>  영속
- 영속성 컨텍스트에 관리되는 상태
  ```java
  EntityManager em = emf.createEntityManager();
  em.getTransaction().begin();
  //객체를 저장한 상태는 영속이다.(조회도 포함(find))
  em.persist(member);
  ```
> 준영속
- 영속성 컨텍스트에 저장되었다가 분리된 상태
```java
  //회원 엔티티를 영속성 컨텍스트에서 분리한 준영속 상태
  em.detach(member);
```
> 삭제
- 삭제된 상태
```java
   // 객체를 삭제한 상태
   em.remove(member);
```

## 영속성 컨텍스트의 이점
> 1차캐시  
- 조회를 할때 할때 영속성 컨텍스트의 1차 캐시에 저장되어있는 엔티티에서 조회
- 저장되어 있지 않은 엔티티도 DB에서 조회 후 1차캐시에 저장 후 반환
> 동일성 보장  
- 1차 캐시로 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공
> 트랜잭션을 지원하는 쓰기 지연  
- INSERT와 같은 경우 1차캐시에 저장되고, INSERT SQL을 생성하여 쓰기 지연 SQL 저장소에 쌓아둔다. 그리고 트랜잭션이 커밋될 때 flush되면서 DB에 날라가고 실제 트랜잭션이 DB에 커밋된다.
> 변경감지(더티 체킹)
- 내부적으로 flush가 일어나면서 1차캐시의 스냅샷과 비교한다. 그리고 UDATE SQL을 생성하여 쓰기 지연 SQL 저장소에 저장한 후 트랜잭션이 커밋될 때 flush되면서 DB에 날라가고 실제 트랜잭션이 DB에 커밋된다.
> 지연 로딩  
- (따로 정리)

## 플러시
> 연속성 컨텍스트의 변경 내용을 데이터베이스에 반영  
- 변경 감지
- 수정된 엔티티를 쓰기 지연 SQL 저장소에 등록
- 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송
  
> 영속성 컨텍스트를 플러시하는 법
- em.flush() - 직접 호출
- 트랜잭션 커밋 - 플러시 자동 호출
- JPQL쿼리 실행 - 플러시 자동 호출  
  
    
**트랜잭션이라는 작업단위가 중요. 커밋 직전에만 동기화 하면 된다.**

## 준영속 상태
> 1. 영속 상태의 엔티티가 영속성 컨텍스트에서 분리  
> 2. 영속성 컨텍스트가 제공하는 기능을 사용 못함
- em.detach(entity) - 특정 엔티티만 준영속 상태로 전환
- em.clear() - 영속성 컨텍스트를 완전히 초기화
- em.close() - 영속성 컨텍스트를 종료

참조 서적 - 자바 ORM 표준 JPA 프로그래밍(김영한)